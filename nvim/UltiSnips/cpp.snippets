

snippet icin "cin to lint" bA
lint $1 = 0; cin >> $1;$0
endsnippet


# Quick access algorithms

snippet dfstemp "quick dfs" bA
VI visited;

void dfs(lint v) {
    if (visited[v]) return;
    visited[v] = true;
    for (lint w : graph[v]) {
        dfs(w);
    }
}
$0
endsnippet

snippet dfstwocolortemp "quick dfs two coloring" bA
VI color;

bool dfs(lint v, lint try_color) {
    if (color[v] != 0) return color[v] == try_color;
    color[v] = try_color;
    for (lint w : graph[v]) {
        if (!dfs(w, 3 - color[v])) {
            return false;
        }
    }
    return false;
}
$0
endsnippet

snippet cycletemp "quick dfs cycle finder" bA
VI visited;

boool dfs(lint v, lint parent) {
    if (visited[v]) return true;
    visited[v] = true;
    for (lint w : graph[v]) {
        if (w != parent && dfs(w, v)) return true;
    }
    return false;
}
$0
endsnippet

snippet bfstemp "quick bfs" bA
VI visited;

void bfs(lint start) {
    QI Q;
    Q.push(start);
    while(!Q.empty()) {
        lint v = Q.front();
        Q.pop();

        for (lint w : graph[v]) {
            if (!visited[w]) {
                visited[w] = true;
                Q.push(w);
            }
        }
    }
}
$0
endsnippet

snippet shortestpath "quick shortest path Dijkstra" bA
lint bfs(lint start, lint end) {
	VI dist(n, -1);
	PQII pq;
	pq.push({0, start});
	while (!pq.empty()) {
		lint d = -pq.top().first;
		lint pos = pq.top().second;
		pq.pop();
		if (dist[pos] != -1) continue;
		dist[pos] = d;
		REP (i, graph[pos]) {
			lint v = graph[pos][i].first;
			lint w = graph[pos][i].second;
			pq.push({-(dist[pos] + w), v});
		}
	}
	return dist[finish];
}
endsnippet

snippet shortpathtemp "quick shortest path finder" bA
VI visited;
VI dist;

void bfs(lint start) {
    QI Q;
    Q.push(start);
    while(!Q.empty()) {
        lint v = Q.front();
        Q.pop();

        for (lint w : graph[v]) {
            if (!visited[w]) {
                visited[w] = true;
                dist[w] = dist[v] + 1;
                Q.push(w);
            }
        }
    }
}
$0
endsnippet

snippet bsfunctemp "quckly binary search the solutions with a funciton" bA
lint x = -1;
lint y = INF;
while (y-x > 1) {
    lint z = (x+y) / 2;
    if (isPossibleWith(x)) {
        x = z;
    } else {
        y = z;
    }
}
$0
endsnippet

snippet bsvectemp "quickly binary search a vector" bA
lint x = -1;
lint y = nums.size();
while (y-x > 1) {
    lint z = (x+y) / 2;
    if (nums[z] <= search) {
        x = z;
    } else {
        y = z;
    }
}
if (x == -1) return -1;
if (nums[x] < search) return -1;
return x;
$0
endsnippet

snippet 1dprefixsum "quick 1D prefixsum" bA
VI prefixsum(n);

void create(lint n, VI nums) {
    for (lint i = 1; i <= n; i++) {
        prefixsum[i] = prefixsum[i-1] + nums[i-1];
    }
}

lint getSegment(lint start, lint end) {
    return prefixsum[end+1] - prefixsum[start];
}
$0
endsnippet

snippet 2dprefixsum "quick 1D prefixsum" bA
VVI prefixsum(w, VI(h));

void create(lint w, lint h, VI nums) {
    for (lint i = 1; i <= h; i++) {
        for (lint j = 1; j <= w+1; j++) {
            prefixsum[i][j] = prefixsum[i-1][j] + prefixsum[i][j-1] - prefixsum[i-1][j-1] + nums[i-1][j-1];
        }
    }
}

lint getSegment(lint x1, lint x2, lint y1, lint y2) {
    return (prefixsum[y2+1][x2+1]
          - prefixsum[y1][x2+1]
          - prefixsum[y2+1][x1]
          + prefixsum[y1][x1])
}
$0
endsnippet

snippet unionfdtemp "quick union-find" bA
VI chef;

lint find(lint v) {
    if (v == chef[v]) return v;
    return chef[v] = find(chef[v]);
}

void unite(lint v, lint w) {
    v = find(v);
    w = find(w);
    if (rand()%2) {
        chef[v] = w;
    } else {
        chef[w] = v;
    }
}

void init() {
    chef = VI(n);
    REP (i, n) {
        chef[i] = i;
    }
}
$0
endsnippet

snippet segtreetemp "quck segtree" bA
lint n;
VI segTree;
lint neutral = 0;

lint query(lint v, lint tree_l, lint tree_r, lint query_l, lint query_r) {
    if (query_r <= tree_l || tree_r <= query_l) return neutral;
    if (query_l <= tree_l && tree_r <= query_r) return segTree[v];

    lint middle = (tree_l + tree_r) / 2;
    lint result_l = query(2*v  , tree_l, middle, query_l, query_r);
    lint result_r = query(2*v+1, middle, tree_r, query_l, query_r);

    return result_r + result_l;
}

void update(lint v, lint tree_l, lint tree_r, lint query_i, lint value) {
    if (query_i + 1 <= tree_l || tree_r <= query_i) return;
    if (query_i == tree_l && tree_r == query_i + 1) {
        segTree[v] = value;
        return;
    }

    lint m = (tree_l + tree_r) / 2;
    update(2*v  , tree_l, m, query_i, value);
    update(2*v+1, m, tree_r, query_i, value);

    segTree[v] = segTree[2 * v] + segTree[2 * v + 1];
}

void printSegTree(lint v, lint tree_l, lint tree_r, lint depth, const VI &segTreePrint) {
    lint mid = (tree_l + tree_r) / 2;
    if (tree_r - tree_l > 1) printSegTree(2 * v, tree_l, mid, depth + 1, segTreePrint);
    REP(i, 4*depth) cout << " ";
    cout << segTreePrint[v] << endl;
    if (tree_r - tree_l > 1) printSegTree(2 * v + 1, mid, tree_r, depth + 1, segTreePrint);
}

void printSeg(const VI &segTreePrint) {
    printf("--------------- Seg Tree -----------------\n");
    printSegTree(1, 0, segTreePrint.size() / 2, 0, segTreePrint);
    printf("------------------------------------------\n");
}
endsnippet

snippet msttemp "quick minimal spanning tree" bA
VVII graph;
lint n;

lint mst() {
    lint weight = 0;
    VB visited(n, false);
    PQII pq;
    pq.push({0, 0});

    /* cout << "in here at least" << dl; */
    while (pq.size() != 0) {
        lint pos = pq.top().second;
        lint dist = -pq.top().first;
        pq.pop();

        if (visited[pos] == true) continue;
        visited[pos] = true;
        weight += dist;
        /* cout << "in here too " << graph[pos].size() << dl; */

        REP (i, graph[pos].size()) {
            lint next = graph[pos][i].first;
            lint edge = graph[pos][i].second;
            if (visited[next] == true) continue;
            pq.push({-edge, next});
        }
    }

    return weight;
}
$0
endsnippet
